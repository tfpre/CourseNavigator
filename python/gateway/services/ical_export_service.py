"""
iCal Export Service - Schedule Export for Registration Intelligence

Implements Ground Truth: Actionable Prioritization
- Generate .ics calendar files from course schedules
- Support for recurring course meetings
- Demo-bounded implementation for presentation
"""

import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import uuid
import re

logger = logging.getLogger(__name__)

@dataclass
class CourseScheduleEntry:
    """Single course with schedule information for calendar export"""
    course_code: str
    title: str
    instructor: str = ""
    time_slot: str = ""  # e.g., "MWF 14:25-15:15"
    location: str = ""
    start_date: datetime = None  # Semester start
    end_date: datetime = None    # Semester end
    
class ICalExportService:
    """Generate iCal calendar files for course schedules"""
    
    def __init__(self):
        # Demo semester dates (Fall 2024)
        self.semester_start = datetime(2024, 8, 26)  # Late August
        self.semester_end = datetime(2024, 12, 13)   # Mid December
        
    def export_schedule(self, courses: List[CourseScheduleEntry], student_name: str = "Student") -> str:
        """
        Generate iCal (.ics) content for a course schedule
        
        Args:
            courses: List of courses with schedule info
            student_name: Student name for calendar title
            
        Returns:
            iCal content as string
        """
        
        # iCal header
        ical_lines = [
            "BEGIN:VCALENDAR",
            "VERSION:2.0",
            "PRODID:-//Cornell CourseNavigator//Course Schedule//EN",
            f"X-WR-CALNAME:{student_name} - Fall 2024 Courses",
            "X-WR-CALDESC:Generated by Cornell CourseNavigator",
            "CALSCALE:GREGORIAN",
            "METHOD:PUBLISH"
        ]
        
        # Add VTIMEZONE for America/New_York (Eastern Time)
        ical_lines.extend([
            "BEGIN:VTIMEZONE",
            "TZID:America/New_York",
            "BEGIN:DAYLIGHT",
            "TZOFFSETFROM:-0500",
            "TZOFFSETTO:-0400",
            "TZNAME:EDT", 
            "DTSTART:20240310T070000",
            "RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU",
            "END:DAYLIGHT",
            "BEGIN:STANDARD",
            "TZOFFSETFROM:-0400",
            "TZOFFSETTO:-0500", 
            "TZNAME:EST",
            "DTSTART:20241103T060000",
            "RRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU",
            "END:STANDARD",
            "END:VTIMEZONE"
        ])
        
        # Generate events for each course
        for course in courses:
            events = self._generate_course_events(course)
            ical_lines.extend(events)
        
        # iCal footer
        ical_lines.append("END:VCALENDAR")
        
        return "\n".join(ical_lines)
    
    def _generate_course_events(self, course: CourseScheduleEntry) -> List[str]:
        """Generate recurring events for a single course"""
        events = []
        
        if not course.time_slot:
            return events
            
        # Parse time slot (e.g., "MWF 14:25-15:15")
        days, start_time, end_time = self._parse_time_slot(course.time_slot)
        if not days:
            return events
            
        # Generate recurring event for each day pattern
        for day_pattern in self._group_consecutive_days(days):
            event_lines = self._create_recurring_event(
                course, day_pattern, start_time, end_time
            )
            events.extend(event_lines)
            
        return events
    
    def _parse_time_slot(self, time_slot: str) -> tuple:
        """Parse time slot string into components
        
        Returns:
            (days_list, start_time_str, end_time_str)
        """
        try:
            # Parse "MWF 14:25-15:15" format
            parts = time_slot.split(' ')
            if len(parts) != 2:
                return [], "", ""
                
            days_str, time_range = parts
            days = list(days_str)  # ['M', 'W', 'F']
            
            start_str, end_str = time_range.split('-')
            return days, start_str, end_str
            
        except (ValueError, IndexError) as e:
            logger.warning(f"Failed to parse time_slot '{time_slot}': {e}")
            return [], "", ""
    
    def _group_consecutive_days(self, days: List[str]) -> List[List[str]]:
        """Group consecutive days for more efficient recurring events
        
        For now, just return each day separately for simplicity
        """
        return [[day] for day in days]
    
    def _create_recurring_event(self, course: CourseScheduleEntry, days: List[str], 
                              start_time: str, end_time: str) -> List[str]:
        """Create a recurring event for specific days"""
        
        # Map day letters to iCal day codes
        day_map = {
            'M': 'MO', 'T': 'TU', 'W': 'WE', 
            'R': 'TH', 'F': 'FR', 'S': 'SA', 'U': 'SU'
        }
        
        # Convert days to iCal format
        ical_days = [day_map.get(day, day) for day in days if day in day_map]
        if not ical_days:
            return []
        
        # Parse time strings  
        try:
            start_hour, start_min = map(int, start_time.split(':'))
            end_hour, end_min = map(int, end_time.split(':'))
        except ValueError:
            logger.warning(f"Failed to parse times: {start_time}-{end_time}")
            return []
        
        # Find first occurrence of the day pattern
        first_occurrence = self._find_first_occurrence(days[0])
        if not first_occurrence:
            return []
            
        # Create datetime objects
        start_dt = first_occurrence.replace(hour=start_hour, minute=start_min, second=0, microsecond=0)
        end_dt = first_occurrence.replace(hour=end_hour, minute=end_min, second=0, microsecond=0)
        
        # Format for iCal with timezone (America/New_York)
        start_local = start_dt.strftime('%Y%m%dT%H%M%S')
        end_local = end_dt.strftime('%Y%m%dT%H%M%S')
        until_local = self.semester_end.strftime('%Y%m%dT%H%M%S')
        
        # Generate unique ID
        uid = str(uuid.uuid4())
        
        # Build event with timezone
        event_lines = [
            "BEGIN:VEVENT",
            f"UID:{uid}",
            f"DTSTART;TZID=America/New_York:{start_local}",
            f"DTEND;TZID=America/New_York:{end_local}",
            f"RRULE:FREQ=WEEKLY;BYDAY={','.join(ical_days)};UNTIL={until_local}",
            f"SUMMARY:{course.course_code}: {course.title}",
            f"DESCRIPTION:Instructor: {course.instructor}\\nCourse: {course.course_code}",
            f"LOCATION:{course.location}",
            "STATUS:CONFIRMED",
            "TRANSP:OPAQUE",
            "END:VEVENT"
        ]
        
        return event_lines
    
    def _find_first_occurrence(self, day_letter: str) -> Optional[datetime]:
        """Find first occurrence of a weekday after semester start"""
        
        # Map day letters to weekday numbers (0=Monday)
        day_to_weekday = {
            'M': 0, 'T': 1, 'W': 2, 'R': 3, 'F': 4, 'S': 5, 'U': 6
        }
        
        target_weekday = day_to_weekday.get(day_letter)
        if target_weekday is None:
            return None
            
        # Find first occurrence
        current = self.semester_start
        while current.weekday() != target_weekday:
            current += timedelta(days=1)
            
        return current
    
    def export_from_course_codes(self, course_codes: List[str], 
                                student_name: str = "Student") -> str:
        """
        Export schedule from course codes using demo data
        
        Args:
            course_codes: List of course codes (e.g., ['CS 4780', 'CS 2110'])
            student_name: Student name for calendar title
            
        Returns:
            iCal content string
        """
        
        # Demo course data - would normally come from database
        demo_courses = {
            "CS 4780": CourseScheduleEntry(
                course_code="CS 4780",
                title="Machine Learning for Intelligent Systems",
                instructor="Prof. Johnson",
                time_slot="MWF 14:25-15:15", 
                location="Olin 155"
            ),
            "CS 4701": CourseScheduleEntry(
                course_code="CS 4701",
                title="Practicum in Artificial Intelligence",
                instructor="Prof. Anderson",
                time_slot="TR 11:40-12:55",
                location="Gates 122"
            ),
            "CS 4740": CourseScheduleEntry(
                course_code="CS 4740", 
                title="Natural Language Processing",
                instructor="Prof. Chen",
                time_slot="TR 09:05-09:55",
                location="Phillips 101"
            ),
            "CS 2110": CourseScheduleEntry(
                course_code="CS 2110",
                title="Object-Oriented Programming and Data Structures", 
                instructor="Prof. Davis",
                time_slot="MWF 10:10-11:00",
                location="Statler Aud"
            ),
            "CS 3110": CourseScheduleEntry(
                course_code="CS 3110",
                title="Data Structures and Functional Programming",
                instructor="Prof. Wilson", 
                time_slot="TR 14:25-15:15",
                location="Gates 114"
            )
        }
        
        # Build course list from codes
        courses = []
        for code in course_codes:
            if code in demo_courses:
                courses.append(demo_courses[code])
            else:
                logger.warning(f"Course {code} not found in demo data")
                
        return self.export_schedule(courses, student_name)